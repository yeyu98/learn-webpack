webpack
- webpack的一些功能
    - 模块化打包方式；
    - 编译高级特性，如typscript、ES6、less、sass之类的；
    - 监听文件反应到浏览器上；
    - 代码压缩、合并以及其他优化；
- webpack简介
    - 是一个静态模块化打包的打包工具；
    - 静态：指的是打包之后的文件都是些静态文件；
    - 模块化：指的是在开发的时候可以使用任何一种模块化方案，比如cjs，esm，但webpack打包之后的文件
              就会磨平不同模块化方案带来的浏览器不支持的问题，同时也能兼容所有浏览器（如不支持模块化的浏览器IE）的运行；
              PS：现代浏览器中支持模块化需要将 script type="module"来开启模块化；
    - 打包：将你所使用的任何一种开发模式以及一些高级特性打包成js、css、html以及一些其他的静态文件的打包工具；
    - 构建原理：从入口开始，会对每个引入的模块生成一个依赖图，如果有些文件没有被引用则不存在于依赖图中；
                之后遍历依赖图对图中的每个模块进行转换（通过loader）打包；
    - 构建过程
        - 初始化参数：解析webpack配置的参数，合并shell传入的参数以及webpack.config文件里的参数得到最终的配置结果；
        - 开始编译：根据上一步得到的配置结果初始化complier对象，注册配置的所有插件，插件会监听webpack构建的生命周期（发布-订阅者模式）并在不同的生命周期里做出反应，执行对象的run方法开始编译；
        - 确认入口：从配置的entry入口开始解析文件构建AST树，找出依赖并递归下去；
        - 编译模块：递归中根据文件类型，调用所有的loader配置对为文件进行转换，再找出该模块的依赖模块，再递归此过程直到所有模块都被转换；
        - 完成模块编译并输出：递归结束之后得到每个文件结果，包含每个模块以及他们的依赖关系，根据entry配置生成代码块chunk；
        - 输出完成：输出所有chunk到指定的output路径中；
- 起步
    - npm install webpack webpack-cli --save-dev
    - webpack-cli：不是必需品，但本质上就是用来解析webpack在package.json中配置后的参数，本质上就是一个函数根据传入的参数来执行webpack的某些动作；
- 配置
    - mode: 模式选择，默认为production，不同的模式默认配置的东西也不一样；
        - production：ugly压缩代码；
        - development
        - none
    - entry
    - output
    - loader（用于对模块源代码做一个转换，转换成webpack认识的js）
        - 手动配置：loader 从右到左（或从下到上）地取值(evaluate)/执行(execute)，每个loader都是一个流程需要一整套的执行链路；
        - 通过module.rules来引入多个loader
            - test<Regx>：匹配文件后缀告诉webpack是哪个文件要使用loader；
            - use<object [] | string []>：使用对应的loader来解析对应的类型的文件；
                - loader: 传入对应的loader；
                - options<object>: 传入当前loader的配置；
        - 内联配置，如import Styles from '!style-loader!css-loader?modules!./styles.css';
    - 样式处理
        - style-loader：生成style标签插入到head里；
        - css-loader：将css转换成webpack所认识的js代码；
            - options.importLoaders: 当css文件中有@import引入的模块时需要返回几个loader之后重新处理一次该模块（根据后面有几个loader来定）；
        - less-loader：仅仅只是将less转换成css；
    - postcss工具（根据browserslist来判断哪些需要转换）
        - css的转换和适配
            - 给浏览器添加前缀；
            - css样式重置；
        - 使用
            - 添加postcss、postcss-loader、postcss-cli（可以不添加）；
                - 通过命令行输出 npx postcss --use autoprefixer -o result.css ./css/test.css
            - 添加配置对应的插件；
                - Autoprefixer：添加样式前缀；
                - postcss-preset-env：将现代样式转换为绝大部分浏览器都能认识的样式，类似于babel的作用  同时也有Autoprefixer的功能；
                - 插件配置项也可以通过postcss.config.js文件来全局配置；
    - 浏览器兼容browserslist
        - css语法、js语法在不同浏览器中的兼容问题的loader（需要确定项目需要支持的浏览器版本）；
        - browserslist工具：负责查询当前条件符合的浏览器，也就是当前浏览器市场占有率，共享目标浏览器的配置;
            - 查询原理是通过canisuse-lite的工具查询caniuse上面所对应的浏览器的数据；
            - 处理兼容
                - Autoprefixer：添加css前缀；
                - babel-loader：js语法兼容；
                - postcss-preset-env：既包含Autoprefixer的功能又可以转换现代css成绝大部分浏览器可以识别的css；
                - eslint-plugin-compat
                - stylelint-no-unsupported-browser-features
                - postcss-normalize
                - obsolete-webpack-plugin
            - 编写规则
                - 百分比：1%，表示市场占有率1%的浏览器；
                - dead： 24个月没有官方支持或更新的浏览器；
                - last 2 versions：每个浏览器最近的两个版本；
                - 并集通过","或or分隔、交集通过 and、非通过not；
    - 其他资源处理
        - 图片处理
            - file-loader：配置file-loader的时候需要通过output.publicPath指定一下静态资源的位置（可解析图片以及字体图标）；
                - options
                    - `[ext]`: 扩展名；
                    - `[name]`: 当前文件的名称；
                    - `[hash]`: 由md4散列函数生成的32位16进制的字符（128位）；
                    - `[contentHash]`: 在file-loader里同hash；
                    - `[hash:<length>]`：可指定生成的hash长度；
                    - outputPath：指定资源存放的路径；
                - 问题
                    - 问题一：打包background-image的时候会多打包一份图片出来，原因是css-loader6以上打包时会将url('xxx.jpg')默认转换成require('xxx.jpg') --- 在loader配置里设置type: 'javascript/auto'；
                    - 问题二：又会导致第二个问题生成的路径中出现/[object%20Module]，原因是新版的file-loader默认采用esModule引入，而css-loader又会默认将url转换成require() cjs引入两种方式不一样导致 --- 设置options.esModule为false；
                    - 问题三：因为这时候的index还放在项目根目录之下因此img的路径其实是在src下的，但打包之后实际的资源其实是在build/下的此时导致两者的路径不一致 --- 设置output.publicPath 为 build/；
            - url-loader：配置图片资源限制在xxkb之下通过url-loader转换成base64，之上的通过file-loader打包 且 只需要配置url-loader即可；
        - 文本处理
            - raw-loader：将txt、cvg或者指定的格式类型文件解析成字符串导出；
                - 扩展知识 
                    - innerText和textContent的区别
                        - textContent任意一个node节点都可以使用，innerText只有Html元素可以使用（有待考证目前还不能确定哪些属于Node节点哪些属于Html元素）；
                        - innerText获取到的只是单纯的文本，textContent可以获取所有子元素的内容包括<script>和<style>元素的文本内容；
                        - innerText受css样式的影响不会展示隐藏的文本内容，而textContent可以展示所有的不受css影响；
        - 资源模块类型（asset module type）：替换原先处理其他资源的loader；
            - asset/resource：发送一个单独的文件并导出url功能类似于file-loader；
                - 如果想将图片放入指定文件夹里则需要设置匹配的图片文件类型里的generator.filename 和原先file-loader设置名字的方法一样但扩展会自动加上".";
                - output.assetModuleFilename 也可以设置输出图片资源的文件名以及文件夹但这个是全局的资源名设置，一旦设置了之后所有的文件都会匹配上并输出到文件夹中，因为是全局资源存放文件夹不建议这么使用；
            - asset/inline：导出资源的data uri功能类似于url-loader；
                - 需要注意的是一旦设置了这个类型所有的图片都会被转换成base64则不需要指定文件存放文件夹以及名字；
            - asset/source：将资源文件转换为字符串导出功能类似于raw-loader；
            - asset：导出资源的data uri或者一个单独的文件url并在这之间做选择，可以指定大小限制，功能类似于url-loader和file-loader；
                - 设置了此类型后需要设置一下parser.dataUrlCondition.maxSize 来指定限制的图片大小；
    - plugin
        - 扩展webpack的功能比如打包压缩、资源管理、坏境变量注入等，可以贯穿webpack的整个生命周期，在不同的生命周期执行不同的任务；
        - CleanWebpackPlugin：再次打包的时候自动清理dist文件；
        - HtmlWebpackPlugin：在dist文件中生成html文件；
            - 原理就是HtmlWebpackPlugin通过ejs模板文件生成html文件之后再插入对应的script、style之类的标签，我们也可以指定使用我们自己的模板文件来生成index.html；
        - DefinePlugin：内置的插件可以全局定义常量，使用时需要从webpack中引入；
        - CopyWebpackPlugin：将某个文件夹下面的一些文件直接复制到dist文件中；
            - 属性 
                - from：指定文件夹；
                - ignoreOptions：该文件夹下不需要copy过去的文件，需要加前缀**/替代from里的文件夹；
    - 模块化原理（对模块化的解析）
        - CommonJs实现原理：
            - 定义一个模块对象以模块路径为key，模块内容为function value；
            - 定义导入函数，此函数需要对模块做缓存且初始化module变量并传入对应的 模块对象中将导出的内容带出来；
            - 通过解构将模块内容从模块对象中取出来使用；
            - PS：将函数前面使用()、!、+、-、~等符号都能将函数变成函数表达式，解析器就能识别并执行 等同立即执行函数；
            - PS：还需要补充知识点()、!、+、-、~、作用域；
        - ES Module实现原理：
            - __webpack_require__.r：将当前模块设置成 [Object Module] 以及 __esModule: true 添加标识；
            - __webpack_require__.o：判断对象中是否存在某个属性 Object.prototype.hasOwnProperty.call 也可以通过 Reflect.has(target, prop) 判断；
            - __webpack_require__.d：遍历esm导出的对象通过Object.defineProperty 劫持 exports中的属性 代理到definition对象（也就是传入的esm中）；
            - 通过r给esm模块添加esModule标识
            - esm导出时会传入module和module.exports 通过d函数定义 module.exports 通过get代理到 definition 并不是直接取值module.exports
        - 补充一旦涉及到esm都需要做一个代理转换 如果只是esm导入则需要先通过n函数之后在通过d转换代理 如果只是esm导出那么这个模块则是通过r添加标识以及通过d代理转换即可
    - source map
        - source map 是一个针对编译转换后js代码与js源码的映射文件，会用在调试中帮助定位到源文件中的某行某列；比如我们在打包的发布生产环境的时候会为了减少js包体积而做的压缩丑化，在比如我们使用ts或coffeescript开发时打包之后也会转换成js，那么这个时候如果我们要调试也需要通过source map来将ts文件与打包后的js文件做映射；
        - .map文件所对应的概念
            - version: 当前source map的版本（source map目前迭代了三个版本）；
            - sources:打包之后源代码所对应的文件路径；
            - names: 存放源代码所有的变量以及对应的压缩后的变量名称（用于映射使用），如果没有压缩的话就是个空数组；
            - mappings: 通过base64的VLQ可变值编码（variable length quantity）来存储所对应的源文件的位置信息如行列；
            - file：打包后的文件存放路径；
            - sourcesContent：源代码的内容；
            - sourceRoot：sources所对应的根目录；
        - 模式原理：
            - none：什么都不设置，production的默认值；
            - eval：eval模式下会将每个webpack模块内容打包成 eval 包裹的字符串且字符串后面会有特定的注释告诉eval执行完打包代码之后还原映射源代码路径//# sourceURL=webpack://learn-webpack/./src/js/math.js?，eval利用的是浏览器对特定注释 //# sourceURL=xxx 自动解析并添加到sources中的特性来调试，无法精准定位到行列，因为映射之后的代码是webpack转译之后的代码；
            - source-map：webpack在开启source map打包之后会在bundle js文件中添加注释 //# sourceMappingURL=xxx.map 告诉浏览器这个文件有对应的source map文件，此时浏览器会根据bundle.js文件以及.map文件将对应的源文件还原，会精确到行列；
            - eval-source-map: 不会单独生成map文件，生成的map会被转成base64之后拼接到eval字符串后面，此时拥有了map可以精确的定位到某行某列；
            - inline-source-map：不会单独生成map文件，会将map的信息通过base64加密之后内联到打包之后的js文件中，此时拥有了map可以精确的定位到某行；
            - cheap-source-map: 和source-map一样但无法精确到列；
            - cheap-module-source-map：对于有loader介入且转换的文件，需要使用该类型的souce-map定位到的代码就不会是loader翻译之后的源码，而是loader翻译之前我们正常编写的源码（等到讲到babel之后再回头尝试）；
            - hidden-source-map: 会隐藏掉bundle.js文件后面用于解析源代码的特殊注释//# sourceMappingURL=bundle.js.map（告诉浏览器source-map在哪个位置），会生成的source-map，但无法跳转到源代码中（一般用于测试使用）；
            - nosources-source-map：会生成错误提示但没有对应的源代码（感觉作用不大...）；
        - 总结：[inline-|hidden-|eval][nosources-?][cheap-?[module-?]]source-map
          - inline生成内联base64转换后的source-map；
          - eval生成eval包含的源代码以及base64转换后的source-map；
          - hidden隐藏source-map无法跳转；
          - cheap生成无法精确定位到列的source-map；
          - module生成针对loader转译之前的source-map；
          - nosources能生成source-map但浏览器解析时只能看到错误信息，无法定位到源码；
          - 开发阶段最佳实践cheap-module-source-map；
        - 疑问
          - 单独的eval到底能不能精准定位到行列？ 不能因为报错提示跳转之后的代码是webpack转译之后的代码
          - nosources是怎么做到只能看到错误提示信息而无法定位到源代码的呢？map文件中没有生成sourcesContent
          - 浏览器是怎么解析//# sourceMappingURL=bundle.js.map 的呢？ 作用是告诉浏览器source-map在哪个位置 浏览器会找到对应的map文件并将其与bundle.js文件结合转换成源代码
          - eval中生成的//# sourceURL=webpack://learn-webpack/./src/js/math.js?又是怎么解析的呢？作用是告诉浏览器sourceURL在哪个位置的 只能与eval结合使用
    - babel
        - 本质上是一个工具链（转译工具）提供语法转换、源代码转换、polyfill（对旧有浏览器的兼容）最终生成能够在不同浏览器中运行的js代码；
        - babel是个轻内核（内核为core）工具，可以只保留核心来根据需要安装不同的插件；
        - 应用场景：es6+语法、jsx、typescript等会将其转换成最终的js运行在不同的浏览器中； 
        - babel插件
            - @babel/core：babel内核；
            - @babel/cli：babel命令行工具可以使得babel通过命令行来执行；
                - npx babel 文件目录或路径 --out-dir xxx（npx执行某个模块的命令）；
            - @babel/preset-env：babel转换预设里面包含所有的plugins（涉及es6、es7、es8...）；
            - @babel/plugins-xxx：转换插件（比如我要转换箭头函数就需要使用箭头函数的转换插件）
                - @babel/plugin-transform-arrow-functions：箭头函数转换插件；
                - @babel/plugin-transform-block-scoping：块级作用域转换插件比如const、let；
        - babel底层原理
          - 解析阶段（Parsing）、转换阶段（Transformation）、代码生成阶段（Code Generate）：
          - babel转译过程
            - 词法分析（对代码做词拆分且标明类型） --->>> tokens数组 --->>> 语法分析（分析具体语义） --->>> AST（抽象语法树）
            - --->>> 遍历AST树（深度优先） --->>> Vistor（访问对象中的节点） --->>> plugins（使用对应的插件转换） 
            - --->>> AST（新的语法树） --->>> 生成新的代码
            - 可在这个网站查看对应的词法、语法分析结果 https://esprima.org/demo/parse.html#
        - 疑问
          - babel/core包含哪些功能代码？ 
          - 单纯在命令行中使用预设没有生效有点奇怪...